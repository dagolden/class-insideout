TODO list for Perl module Class::InsideOut

# Planned todos around core functionality - 1.0 roadmap

- cleanup code detection to use "defined &{"$class\::$fcn"}" style
- pull DDS code out to separate branch

# Todos after 1.0

- add support for new DDS serialization hooks
- test DDS on other serialization tests
- document DDS support
- accessor style options
- register() sugar
- write FAQs
- expand documentation (cookbook? quick-start? notes on writing Builders)
- document some internal introspection functions (e.g. _evert/_revert)

# Possible todos depending on demand

- add public introspection methods (property list and options?)
- accessor privacy => "protected" and matching property alias
- look into support for cloning tied objects(?) in the blessed hash(?)
- pre-clone user hook?? (waiting for someone to say they need it)

#--------------------------------------------------------------------------#
# register sugar ?!
#--------------------------------------------------------------------------#

# if argument is blessed -- just register it
# (this matches the existing behavior)
sub new { register( bless {}, shift ) }

# if argument is reference and not blessed, bless into the second 
# argument (or else the caller's class)
sub new{ register {}, shift }

# with one argument, not a reference, register should bless an 
# anonymous scalar into the first argument and return
sub new { register shift };

# then could provide an optional "new" function which is just the
# example above

#--------------------------------------------------------------------------#
# Thoughts about property accessor styles and options
#--------------------------------------------------------------------------#

# have to be careful of interrelationship between style and custom prefixes;
# maybe don't allow custom prefixes at all

Class::InsideOut::options(
  accessor_style => 'perl', # default
        # "combined"; "perl" => foo() and foo(x)
        # "get_set"; "java"  => get_foo() and set_foo(x)
        # "eiffel"           => foo() and set_foo(x)
        
  get_prefix => 'get_', # maybe don't bother (YAGNI)
  set_prefix => 'set_', # maybe don't bother (YAGNI)
  privacy => 'public',  # create accessors for everything given to properties
                       # or 'readonly' or 'protected' or 'private'
  set_hook => \&coderef,  # mutator argument filtered through this
                            # will catch die message for error
  set_returns => 'self' # or 'newvalue' or 'oldvalue'
);

#--------------------------------------------------------------------------#
# FAQ ideas
#--------------------------------------------------------------------------#

* Security (c.f use perl post)

* advisory encapsulation

#--------------------------------------------------------------------------#
# Cookbook ideas
#--------------------------------------------------------------------------#

* Outside-in pattern

* Property aliasing:  ( should work, but what about Storable? )
    assets => my %assets;
    wealth => my %assets;
